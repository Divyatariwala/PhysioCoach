{% extends "posture/base.html" %}
{% load static %}

{% block content %}
<div class="exercise-page py-5" style="min-height:100vh; font-family: 'Roboto', sans-serif;">
  <div class="container">
    <div class="row g-4 g-lg-5 align-items-start">

      <!-- Left Panel: Video -->
      <div class="col-lg-7">
        <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="overlay"></canvas>
        </div>
      </div>

      <!-- Right Panel: Feedback + Reps + Controls -->
      <div class="col-lg-5">
        <div class="glass-card p-4 mb-4">
          <h2 class="fw-bold mb-3 text-dark" style="font-family: 'Montserrat', sans-serif;">üèãÔ∏è Exercise Info</h2>

          <!-- Exercise Dropdown -->
          <div class="mb-3">
            <label class="form-label fw-semibold text-dark">Select Exercise</label>
            <div class="custom-select-wrapper">
              <div class="custom-select" id="exerciseSelect">
                <div class="custom-select-trigger">Select your exercise</div>
                <div class="custom-options">
                  {% for exercise in exercises %}
                  <div class="custom-option" data-value="{{ exercise.exercise_id }}">
                    {{ exercise.name }}
                  </div>
                  {% empty %}
                  <div class="custom-option" data-value="">No exercises available</div>
                  {% endfor %}
                </div>
              </div>
              <input type="hidden" name="exercise" id="exerciseInput">
            </div>
          </div>

          <!-- Exercise Details -->
          <div id="exerciseInfo" class="glass-card-inner p-3 mt-3 mb-3">
            <p><strong>Description:</strong> <span id="exerciseDescription"></span></p>
            <p><strong>Target Muscle:</strong> <span id="exerciseMuscle"></span></p>
            <p><strong>Difficulty Level:</strong> <span id="exerciseDifficulty"></span></p>
          </div>

          <!-- Feedback & Reps/Time -->
          <div class="feedback-section mt-3">
            <p class="fw-bold mb-2">Posture Feedback:</p>
            <div id="postureFeedback" class="feedback-box mb-3">
              Stand straight and get ready! üöÄ
            </div>
            <div class="reps-time d-flex justify-content-between text-dark fw-bold fs-5 mb-3">
              <span id="repCount">Reps: 0</span>
              <span id="sessionTime">Time: 0s</span>
            </div>
            <p id="postureAccuracy" class="fw-bold text-center fs-5 text-dark">Accuracy: 0%</p>
          </div>

          <!-- Control Buttons -->
          <div class="d-flex gap-3 mt-4 flex-wrap">
            <button class="btn glass-btn-start flex-fill" id="startBtn">Start</button>
            <button class="btn glass-btn-stop flex-fill" id="stopBtn">Stop</button>
          </div>

          <!-- Demo Video -->
          <div class="mt-4 glass-card-inner p-3 text-center">
            <video id="demoVideo" width="100%" controls style="border-radius: 12px;"></video>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<style>
/* Glass Cards */
.glass-card { 
  background: rgba(255,255,255,0.2); 
  backdrop-filter: blur(12px); 
  border-radius:20px; 
  border:1px solid rgba(255,255,255,0.3);
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
}
.glass-card-inner { 
  background: rgba(255,255,255,0.15); 
  backdrop-filter: blur(8px); 
  border-radius:15px; 
  border:1px solid rgba(255,255,255,0.2);
}

/* Feedback Box */
.feedback-box {
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(8px);
  border-radius: 15px;
  padding: 15px;
  font-size: 1.2rem;
  min-height: 80px;
  text-align: center;
  transition: all 0.3s;
  color: #000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

/* Buttons */
.glass-btn-start, .glass-btn-stop {
  border-radius:25px; 
  font-weight:600; 
  padding:12px 25px; 
  font-size:1rem; 
  border:none; 
  transition:all 0.3s;
}
.glass-btn-start { background: rgba(76, 175, 80, 0.6); color:#fff;}
.glass-btn-stop { background: rgba(233, 76, 60, 0.6); color:#fff;}
.glass-btn-start:hover { background: rgba(76,175,80,0.9); box-shadow:0 0 15px rgba(76,175,80,0.7);}
.glass-btn-stop:hover { background: rgba(233,76,60,0.9); box-shadow:0 0 15px rgba(233,76,60,0.7);}

/* Video Container */
.video-container {
  position: relative;
  width: 100%;
  height: 80vh;
  border-radius:20px;
  overflow:hidden;
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(6px);
  border:1px solid rgba(255,255,255,0.2);
}
video#video { width:100%; height:100%; object-fit: cover; }
canvas#overlay { position:absolute; top:0; left:0; width:100%; height:100%; }

/* Custom Dropdown */
.custom-select-wrapper { position:relative; user-select:none; width:100%; margin-bottom:1rem; z-index:10;}
.custom-select { position:relative; background: rgba(255,255,255,0.25); backdrop-filter: blur(12px); border-radius:18px; padding:12px 15px; cursor:pointer; color:#1b4332;}
.custom-select-trigger::after { content:''; position:absolute; top:50%; right:15px; border-left:6px solid transparent; border-right:6px solid transparent; border-top:6px solid #1b4332; transform:translateY(-50%);}
.custom-options { position:absolute; top:100%; left:0; width:100%; background: rgba(255,255,255,0.95); border-radius:15px; max-height:180px; overflow-y:auto; display:none; z-index:2000; margin-top:5px;}
.custom-option { padding:12px 20px; cursor:pointer; transition: background 0.3s;}
.custom-option:hover { background: rgba(76,175,80,0.2);}
.custom-options.show { display:block;}

/* Responsive */
@media (max-width:991px){
  .row { flex-direction: column-reverse; }
  .video-container { height: 50vh; margin-bottom:20px; }
  .feedback-box { font-size:1rem; min-height:70px; }
}
@media (max-width:575px){
  .glass-card { padding: 15px; }
  .glass-btn-start, .glass-btn-stop { font-size:0.9rem; padding:10px; }
  .reps-time { flex-direction: column; gap:5px; }
}
</style>
{% endblock %}



{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', async () => {

const video = document.getElementById("video");
const overlay = document.getElementById("overlay");
const ctx = overlay.getContext("2d");
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');

const repCountEl = document.getElementById("repCount");
const sessionTimeEl = document.getElementById("sessionTime");
const postureFeedback = document.getElementById("postureFeedback");
const postureAccuracy = document.getElementById("postureAccuracy");

const exerciseTrigger = document.querySelector('#exerciseSelect .custom-select-trigger');
const exerciseOptions = document.querySelector('#exerciseSelect .custom-options');
const exerciseValues = document.querySelectorAll('#exerciseSelect .custom-option');
const exerciseInput = document.getElementById('exerciseInput');

const descriptionEl = document.getElementById("exerciseDescription");
const muscleEl = document.getElementById("exerciseMuscle");
const difficultyEl = document.getElementById("exerciseDifficulty");
const demoVideoEl = document.getElementById("demoVideo");

const exerciseData = JSON.parse('{{ exercise_data_json|default:"[]"|escapejs }}');

let detector=null, sessionActive=false, repCount=0, repState="UP", startTime=null, lastRepTime=0, repCooldown=600;
let keypointHistory=[];

// --- Helper functions ---
function getAngle(a,b,c){
  const ab={x:a.x-b.x, y:a.y-b.y};
  const cb={x:c.x-b.x, y:c.y-b.y};
  const dot=ab.x*cb.x + ab.y*cb.y;
  const magAB=Math.sqrt(ab.x**2+ab.y**2);
  const magCB=Math.sqrt(cb.x**2+cb.y**2);
  return Math.acos(dot/(magAB*magCB))*(180/Math.PI);
}

function smoothKeypoints(keypoints){
  keypointHistory.push(keypoints);
  if(keypointHistory.length>5) keypointHistory.shift();
  return keypoints.map((kp,idx)=>{
    let avgX=0, avgY=0, avgScore=0;
    keypointHistory.forEach(frame=>{ avgX+=frame[idx].x; avgY+=frame[idx].y; avgScore+=frame[idx].score; });
    const n = keypointHistory.length;
    return {...kp, x:avgX/n, y:avgY/n, score:avgScore/n};
  });
}

async function initDetector(){
  detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet);
  startBtn.disabled=false;
  console.log("‚úÖ Pose detector ready");
}
await initDetector();

// --- Dropdown logic ---
exerciseTrigger.addEventListener('click', e=>{e.stopPropagation(); exerciseOptions.classList.toggle('show');});
exerciseValues.forEach(option=>{
  option.addEventListener('click', ()=>{
    exerciseTrigger.textContent = option.textContent;
    exerciseInput.value = option.dataset.value;
    exerciseOptions.classList.remove('show');
    updateExerciseInfo();
  });
});
document.addEventListener('click', ()=>exerciseOptions.classList.remove('show'));
if(exerciseValues.length>0) exerciseValues[0].click();

function updateExerciseInfo(){
  const selectedId = parseInt(exerciseInput.value);
  const exercise = exerciseData.find(e=>e.id===selectedId);
  if(exercise){
    descriptionEl.textContent = exercise.description;
    muscleEl.textContent = exercise.target_muscle;
    difficultyEl.textContent = exercise.difficulty_level;
    demoVideoEl.src = exercise.video_demo_url;
  } else {
    descriptionEl.textContent=""; muscleEl.textContent=""; difficultyEl.textContent=""; demoVideoEl.src="";
  }
}

// --- Draw keypoints ---
function drawKeypoints(pose){
  const scaleX = overlay.width/video.videoWidth;
  const scaleY = overlay.height/video.videoHeight;
  const points = pose.keypoints.filter(k=>k.score>0.5);
  points.forEach(k=>{
    ctx.beginPath();
    ctx.arc(k.x*scaleX, k.y*scaleY, 6, 0, 2*Math.PI);
    ctx.fillStyle="#ff1744";
    ctx.fill();
  });

  const connections=[
    ['left_shoulder','right_shoulder'], ['left_shoulder','left_elbow'], ['left_elbow','left_wrist'],
    ['right_shoulder','right_elbow'], ['right_elbow','right_wrist'],
    ['left_shoulder','left_hip'], ['right_shoulder','right_hip'],
    ['left_hip','right_hip'], ['left_hip','left_knee'], ['left_knee','left_ankle'],
    ['right_hip','right_knee'], ['right_knee','right_ankle']
  ];
  connections.forEach(([a,b])=>{
    const pa = points.find(p=>p.name===a);
    const pb = points.find(p=>p.name===b);
    if(pa && pb){
      ctx.beginPath();
      ctx.moveTo(pa.x*scaleX, pa.y*scaleY);
      ctx.lineTo(pb.x*scaleX, pb.y*scaleY);
      ctx.strokeStyle="#ff1744"; ctx.lineWidth=3;
      ctx.stroke();
    }
  });
}

// --- Squat detection ---
const exerciseRules = {
  squat: (pose) => {
    const now = Date.now();
    const keypoints = smoothKeypoints(pose.keypoints);

    const leftHip = keypoints.find(k => k.name === 'left_hip');
    const rightHip = keypoints.find(k => k.name === 'right_hip');
    const leftKnee = keypoints.find(k => k.name === 'left_knee');
    const rightKnee = keypoints.find(k => k.name === 'right_knee');
    const leftAnkle = keypoints.find(k => k.name === 'left_ankle');
    const rightAnkle = keypoints.find(k => k.name === 'right_ankle');
    const leftShoulder = keypoints.find(k => k.name === 'left_shoulder');
    const rightShoulder = keypoints.find(k => k.name === 'right_shoulder');
    const nose = keypoints.find(k => k.name === 'nose');

    // Visibility check (head to knees)
    const essentialPoints = [nose,leftShoulder,rightShoulder,leftHip,rightHip,leftKnee,rightKnee];
    const visiblePoints = essentialPoints.filter(p=>p && p.score>0.5);
    if(visiblePoints.length < essentialPoints.length){
      postureFeedback.textContent = "üì∏ Please show your body fully from head to knees!";
      postureAccuracy.textContent = "Accuracy: 0%";
      return;
    }

    // Knee angles
    const leftKneeAngle = (leftHip && leftKnee && leftAnkle) ? getAngle(leftHip,leftKnee,leftAnkle) : 180;
    const rightKneeAngle = (rightHip && rightKnee && rightAnkle) ? getAngle(rightHip,rightKnee,rightAnkle) : 180;

    // Back angle
    const leftBack = (leftShoulder && leftHip && leftKnee) ? getAngle(leftShoulder,leftHip,leftKnee) : 180;
    const rightBack = (rightShoulder && rightHip && rightKnee) ? getAngle(rightShoulder,rightHip,rightKnee) : 180;
    const backAngle = (leftBack + rightBack)/2;

    const postureScore = backAngle>160 ? 100 : backAngle>140 ? 80 : backAngle>120 ? 60 : 40;
    postureAccuracy.textContent = `Accuracy: ${postureScore}%`;

    // Squat state
    let repDown=false, repUp=false;
    const kneeAngleAvg = (leftKneeAngle + rightKneeAngle)/2;
    repDown = kneeAngleAvg < 100;
    repUp = kneeAngleAvg > 160;

    // --- Feedback messages ---
    if(postureScore < 70){
      postureFeedback.textContent = "üí™ Keep your back nice and straight!";
    } else if(repState==="UP" && repDown){
      postureFeedback.textContent = "‚¨áÔ∏è Going down‚Ä¶ Feel the burn!";
    } else if(repState==="DOWN" && repUp){
      postureFeedback.textContent = "‚¨ÜÔ∏è Coming up‚Ä¶ Almost there!";
    } else if(postureScore>=85){
      postureFeedback.textContent = "üåü Perfect posture! Keep it up!";
    } else {
      postureFeedback.textContent = "üëç Nice! Maintain your squat form.";
    }

    // --- Rep counting ---
    if(repDown && repState==="UP" && postureScore>=70) repState="DOWN";
    if(repUp && repState==="DOWN" && postureScore>=70 && (now-lastRepTime)>repCooldown){
      repCount++;
      repState="UP";
      lastRepTime=now;
      postureFeedback.textContent = "‚úÖ Rep counted! Keep going!";
      console.log("‚úÖ Rep counted:", repCount);
    }

    repCountEl.textContent=`Reps: ${repCount}`;
    sessionTimeEl.textContent=`Time: ${Math.floor((now-startTime)/1000)}s`;
  }
};

// --- Start session ---
startBtn.addEventListener('click', async ()=>{
  if(!detector) return alert("Pose detector not ready");
  if(sessionActive) return;

  const selectedExercise = exerciseData.find(e=>e.id===parseInt(exerciseInput.value));
  if(!selectedExercise||!selectedExercise.name) return alert("Select an exercise first");

  const exerciseKey = selectedExercise.name.toLowerCase().replace(/\s+/g,'_');

  sessionActive=true; repCount=0; repState="UP"; startTime=Date.now();
  postureFeedback.textContent="üì∏ Initializing...";

  const stream = await navigator.mediaDevices.getUserMedia({video:true});
  video.srcObject=stream;

  video.addEventListener('loadeddata',()=>detectFrame(exerciseKey));
});

// --- Detection loop ---
async function detectFrame(exerciseKey){
  if(!sessionActive) return;
  overlay.width=video.videoWidth; overlay.height=video.videoHeight;
  ctx.clearRect(0,0,overlay.width,overlay.height);

  const poses = await detector.estimatePoses(video);
  poses.forEach(p=>{
    drawKeypoints(p);
    if(exerciseRules[exerciseKey]) exerciseRules[exerciseKey](p);
  });

  requestAnimationFrame(()=>detectFrame(exerciseKey));
}

// --- Stop session ---
stopBtn.addEventListener('click', ()=>{
  if(!sessionActive) return;
  sessionActive=false;
  video.srcObject?.getTracks().forEach(track=>track.stop());
  postureFeedback.textContent="‚úÖ Session stopped.";
  postureAccuracy.textContent = "Accuracy: 0%";
});
});
</script>
{% endblock %}
